name: Build, Test and Deploy FastAPI Application

env:
  PYTHON_VERSION: '3.13'
  DOCKER_IMAGE: koval01/telegram-me

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

permissions:
  contents: write
  packages: write
  issues: write
  pull-requests: write

jobs:
  code-quality:
    name: Code Quality Checks
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ["3.10", "3.11", "3.12", "3.13"]

    steps:
      - uses: actions/checkout@v4

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}

      - name: Cache Python dependencies
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache/pip
            ~/.cache/pypoetry
            venv/
          key: ${{ runner.os }}-python-${{ matrix.python-version }}-${{ hashFiles('**/requirements.txt', '**/pyproject.toml') }}
          restore-keys: |
            ${{ runner.os }}-python-${{ matrix.python-version }}-

      - name: Install dependencies
        run: |
          python -m pip install -U pip
          python -m pip install -r requirements.txt
          pip install pylint radon

      - name: Analysing the code with pylint
        run: |
          pylint $(git ls-files '*.py') --exit-zero

      - name: Run Radon analysis
        if: matrix.python-version == '3.13'
        run: |
          echo "## Cyclomatic Complexity (CC)"
          radon cc $(git ls-files '*.py') -nc
          echo ""
          echo "## Maintainability Index (MI)"
          radon mi $(git ls-files '*.py') -s
          echo ""
          echo "## Halstead Metrics"
          radon hal $(git ls-files '*.py')

  test:
    name: Run Tests
    runs-on: ubuntu-latest
    needs: [code-quality]

    steps:
      - uses: actions/checkout@v4

      - name: Create .env.local for testing
        run: |
          echo "REDIS_URL=${{ secrets.REDIS_URL }}" > .env.local
          echo "Created .env.local file with REDIS_URL"

      - name: Set up Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Cache Python dependencies
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache/pip
            ~/.cache/pypoetry
            venv/
          key: ${{ runner.os }}-python-${{ env.PYTHON_VERSION }}-${{ hashFiles('**/requirements.txt', '**/pyproject.toml') }}
          restore-keys: |
            ${{ runner.os }}-python-${{ env.PYTHON_VERSION }}-

      - name: Install dependencies
        run: |
          python -m pip install -U pip
          python -m pip install -r requirements.txt
          pip install uvicorn httpx pytest

      - name: Run FastAPI app in background
        run: |
          nohup uvicorn app.main:app --host 0.0.0.0 --port 8000 > server.log 2>&1 &
          echo "Waiting for server to start..."
          sleep 10

      - name: Test API endpoints
        run: |
          echo "Testing API endpoints..."
          
          # Health check first
          echo "GET /healthz"
          if curl -s -f http://127.0.0.1:8000/healthz; then
            echo "✓ Health check passed"
          else
            echo "✗ Health check failed"
            exit 1
          fi

          # Test other endpoints
          endpoints=(
            "/"
            "/v1/preview/durov"
            "/v1/post/durov/440"
            "/v1/more/durov/after/300"
            "/v1/more/durov/before/300"
            "/v1/body/durov"
            "/v1/body/durov?position=350"
          )

          for endpoint in "${endpoints[@]}"; do
            echo "Testing $endpoint"
            status_code=$(curl -s -o /dev/null -w "%{http_code}" "http://127.0.0.1:8000$endpoint")
            echo "Status: $status_code"
            if [ "$status_code" -ge 400 ]; then
              echo "✗ Endpoint $endpoint returned error: $status_code"
              exit 1
            fi
          done

          echo "✓ All endpoint tests passed"

      - name: Show server logs (if failed)
        if: failure()
        run: |
          echo "=== Server Logs ==="
          cat server.log

  docker-build-test:
    name: Build and Test Docker Image
    runs-on: ubuntu-latest
    needs: [test]

    steps:
      - uses: actions/checkout@v4

      - name: Create .env.local for Docker build
        run: |
          echo "REDIS_URL=${{ secrets.REDIS_URL }}" > .env.local
          echo "Created .env.local file with REDIS_URL"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Get short SHA and current date
        id: vars
        run: |
          echo "short_sha=${GITHUB_SHA::8}" >> $GITHUB_OUTPUT
          echo "build_date=$(date +'%Y.%m.%d')" >> $GITHUB_OUTPUT

      - name: Build Docker image for testing
        uses: docker/build-push-action@v5
        with:
          context: .
          file: Dockerfile
          load: true
          tags: ${{ env.DOCKER_IMAGE }}:test-${{ steps.vars.outputs.short_sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            REDIS_URL=${{ secrets.REDIS_URL }}

      - name: Test Docker image
        run: |
          echo "Starting Docker container for testing..."
          docker run -d -p 8000:3000 --env-file .env.local --name fastapi-test ${{ env.DOCKER_IMAGE }}:test-${{ steps.vars.outputs.short_sha }}
          
          echo "Waiting for container to be ready..."
          for i in {1..30}; do
            if curl -s http://localhost:8000/healthz > /dev/null; then
              echo "✓ Container is ready!"
              break
            fi
            echo "Waiting for container to be ready... ($i/30)"
            sleep 2
          done

          # Test health endpoint
          echo "Testing health endpoint..."
          curl -f http://localhost:8000/healthz || (echo "✗ Health check failed" && exit 1)

          # Test basic functionality
          echo "Testing basic endpoints..."
          curl -s http://localhost:8000/ | grep -q "Swagger" && echo "✓ Root endpoint working" || (echo "✗ Root endpoint failed" && exit 1)

          echo "✓ All Docker tests passed"

          # Cleanup
          docker stop fastapi-test
          docker rm fastapi-test

  build-push:
    name: Build and Push Multi-arch Docker Image
    runs-on: ubuntu-latest
    needs: [docker-build-test]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - uses: actions/checkout@v4

      - name: Create .env.local for production build
        run: |
          echo "REDIS_URL=${{ secrets.REDIS_URL }}" > .env.local
          echo "Created .env.local file with REDIS_URL"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: |
            ${{ env.DOCKER_IMAGE }}
            ghcr.io/${{ github.repository }}
          tags: |
            type=raw,value=latest,enable={{is_default_branch}}
            type=sha,format=short,prefix=

      - name: Build and push multi-arch Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            REDIS_URL=${{ secrets.REDIS_URL }}

  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [ build-push ]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - uses: actions/checkout@v4

      - name: Get version info
        id: vars
        run: |
          echo "short_sha=${GITHUB_SHA::8}" >> $GITHUB_OUTPUT
          echo "build_date=$(date +'%Y.%m.%d')" >> $GITHUB_OUTPUT

      - name: Create Automated Release
        uses: softprops/action-gh-release@v2
        with:
          name: "Auto: ${{ steps.vars.outputs.build_date }}-${{ steps.vars.outputs.short_sha }}"
          tag_name: "auto-${{ steps.vars.outputs.build_date }}-${{ steps.vars.outputs.short_sha }}"
          generate_release_notes: true
          draft: true
          prerelease: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  deploy:
    name: Deploy to Servers
    runs-on: ubuntu-latest
    needs: [build-push]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - name: Create .env.local for deployment
        run: |
          echo "REDIS_URL=${{ secrets.REDIS_URL }}" > .env.local
          echo "Created .env.local file with REDIS_URL"

      - name: Deploy to servers
        run: |
          # Save SSH private key to file
          echo "${{ secrets.SSH_KEY }}" > private_key
          chmod 600 private_key
          
          # Split servers IPs into array
          SERVERS=(${{ secrets.SERVERS_IPS }})
          
          # Copy .env.local to servers and deploy
          DEPLOY_COMMAND="docker pull ${{ env.DOCKER_IMAGE }}:latest && \
                         docker stop telegram-me || true && \
                         docker rm telegram-me || true && \
                         docker run -d --name telegram-me -p 8000:3000 --env-file env.app ${{ env.DOCKER_IMAGE }}:latest"
          
          HEALTH_CHECK="sleep 30 && curl -f http://localhost:8000/healthz && echo '✓ Health check passed'"
          
          # Loop through each server and execute command
          for SERVER_IP in "${SERVERS[@]}"; do
            echo "Deploying to server: $SERVER_IP"
            
            # Copy .env.local to server
            scp -o StrictHostKeyChecking=no -i private_key .env.local ubuntu@$SERVER_IP:~/env.app || echo "⚠️ Failed to copy .env.local to $SERVER_IP"
            
            # Deploy
            ssh -o StrictHostKeyChecking=no -i private_key ubuntu@$SERVER_IP "$DEPLOY_COMMAND" || echo "⚠️ Deployment failed on $SERVER_IP"
            
            echo "Health checking server: $SERVER_IP"
            ssh -o StrictHostKeyChecking=no -i private_key ubuntu@$SERVER_IP "$HEALTH_CHECK" || echo "⚠️ Health check failed on $SERVER_IP"
            
            echo "Checking running containers on $SERVER_IP"
            ssh -o StrictHostKeyChecking=no -i private_key ubuntu@$SERVER_IP "docker ps" || echo "⚠️ Failed to check containers on $SERVER_IP"
          done
          
          # Test external health check
          echo "Testing external health check..."
          curl -s -f 'https://telegram-me.ignorelist.com/healthz' && echo "✓ External health check passed" || echo "⚠️ External health check failed"
          
          # Cleanup
          rm -f private_key .env.local
